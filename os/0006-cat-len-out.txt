; - setup UART
; - read UART to memory
; - read non-commented 1s and 0s to memory
; - print memory

; move 0xFE200000 into r8 and 0xFE201000 into r9

	; move 0xFE20 << 16 into r8
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r8 <= 0xFE20 << 1*16
	; 1 1 0 1 0 0 1 0 1 01 1111 1110 0010 0000 01000
	; 11010010 10111111 11000100 00001000
	; now, reverse the bytes:
	00001000 11000100 10111111 11010010

	; add 0x1000 to r8 to move 0xFE201000 into r9
	; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn + (uimm << (shift ? 12 : 0))
	; r9 <= r8 + (0x1 << (1 ? 12 : 0))
	; 1 0 0 1 0 0 0 1 0 1 0000 0000 0001 01000 01001
	; 10010001 01000000 00000101 00001001
	; now, reverse the bytes:
	00001001 00000101 01000000 10010001

; disable UART

	; store 0x0 into *(r9+0x30)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0x30) <= r31
	; 1 0 1 1 1 0 0 0 0 0 0 000110000 0 0 01001 11111
	; 10111000 00000011 00000001 00111111
	; now, reverse the bytes:
	00111111 00000001 00000011 10111000

; disable GPIO pin pull up/down

	; store 0x0 into *(r8+0x94)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r8 + 0x94) <= r31
	; 1 0 1 1 1 0 0 0 0 0 0 010010100 0 0 01000 11111
	; 10111000 00001001 01000001 00011111
	; now, reverse the bytes:
	00011111 01000001 00001001 10111000

; delay for 150 cycles

	; move 150 (0x96) into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0x96 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0111 1000 00000
	; 11010010 10000000 00001111 00000000
	; now, reverse the bytes:
	11000000 00010010 10000000 11010010

	; subtract 1 from r0
	; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn - (uimm << (shift ? 12 : 0))
	; r0 <= r0 - (1 << (0 ? 12 : 0))
	; 1 1 0 1 0 0 0 1 0 0 0000 0000 0001 00000 00000
	; 11010001 00000000 00000100 00000000
	; now, reverse the bytes:
	00000000 00000100 00000000 11010001

	; compare r0 to r31
	; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
	; Rn ? Rm
	; r0 ? r31
	; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00000 0 0 0 0 0
	; 11111010 01011111 11110000 00000000
	; now, reverse the bytes:
	00000000 11110000 01011111 11111010

	; if greater than, jump back two instructions
	; 0 1 0 1 0 1 0 0 imm19 0 cond4
	; imm = -2 ; cond = 1100
	; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1110 0 1100
	; 01010100 11111111 11111111 11001100
	; now, reverse the bytes:
	11001100 11111111 11111111 01010100

; ahhhhhhhhhhhhhhhh

	; move 1100 0000 0000 0000 into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 1100 0000 0000 0000 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 1100 0000 0000 0000 00000
	; 11010010 10011000 00000000 00000000
	; now, reverse the bytes:
	00000000 00000000 10011000 11010010

	; store r0 into GPIO clock 0
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r8 + 0x98) <= r0
	; 1 0 1 1 1 0 0 0 0 0 0 010011000 0 0 01000 00000
	; 10111000 00001001 10000001 00000000
	; now, reverse the bytes:
	00000000 10000001 00001001 10111000

; disable GPIO pin pull up/down clock 1

	; store 0x0 into *(r8+0x9C)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r8 + 0x9C) <= r31
	; 1 0 1 1 1 0 0 0 0 0 0 010011100 0 0 01000 11111
	; 10111000 00001001 11000001 00011111
	; now, reverse the bytes:
	00011111 11000001 00001001 10111000

; delay for 150 cycles

	; move 150 (0x96) into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0x96 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 1001 0110 00000
	; 11010010 10000000 00010010 11000000
	; now, reverse the bytes:
	11000000 00010010 10000000 11010010

	; subtract 1 from r0
	; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn - (uimm << (shift ? 12 : 0))
	; r0 <= r0 - (1 << (0 ? 12 : 0))
	; 1 1 0 1 0 0 0 1 0 0 0000 0000 0001 00000 00000
	; 11010001 00000000 00000100 00000000
	; now, reverse the bytes:
	00000000 00000100 00000000 11010001

	; compare r0 to r31
	; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
	; Rn ? Rm
	; r0 ? r31
	; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00000 0 0 0 0 0
	; 11111010 01011111 11110000 00000000
	; now, reverse the bytes:
	00000000 11110000 01011111 11111010

	; if greater than, jump back two instructions
	; 0 1 0 1 0 1 0 0 imm19 0 cond4
	; imm = -2 ; cond = 1100
	; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1110 0 1100
	; 01010100 11111111 11111111 11001100
	; now, reverse the bytes:
	11001100 11111111 11111111 01010100

; disable GPIO pin pull up/down clock 0

	; store 0x0 into *(r8+0x98)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r8 + 0x98) <= r31
	; 1 0 1 1 1 0 0 0 0 0 0 010011000 0 0 01000 11111
	; 10111000 00001001 10000001 00011111
	; now, reverse the bytes:
	00011111 10000001 00001001 10111000

; disable GPIO pin pull up/down clock 1

	; store 0x0 into *(r8+0x9C)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r8 + 0x9C) <= r31
	; 1 0 1 1 1 0 0 0 0 0 0 010011100 0 0 01000 11111
	; 10111000 00001001 11000001 00011111
	; now, reverse the bytes:
	00011111 11000001 00001001 10111000

; clear all pending interrupts

	; move 0x7ff into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0x7ff << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0111 1111 1111 00000
	; 11010010 10000000 11111111 11100000
	; now, reverse the bytes:
	11100000 11111111 10000000 11010010

	; store r0 into *(r9+0x44)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0x44) <= r0
	; 1 0 1 1 1 0 0 0 0 0 0 001000100 0 0 01001 00000
	; 10111000 00000100 01000001 00100000
	; now, reverse the bytes:
	00100000 01000001 00000100 10111000

; set baud rate to 115200 given a ? Mhz clock
; NVM, experimentally derived from c3r3s, ignore the following calculations
; AHHH BDR = (3 000 000)/(16 * 115200) = 1.6276
; AHHH BDR_F = 0.6276
; AHHH BDR_I = 1 = 0x1
; AHHH m = int((0.6276*64)+0.5) = 40 = 0x28

; store 0x1a into BRD_I @ *(r9+0x24)

	; move 0x1a into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0x1a << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0001 1010 00000
	; 11010010 10000000 00000011 01000000
	; now, reverse the bytes:
	01000000 00000011 10000000 11010010

	; store r0 into *(r9+0x24)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0x24) <= r0
	; 1 0 1 1 1 0 0 0 0 0 0 0 0010 0100 0 0 01001 00000
	; 10111000 00000010 01000001 00100000
	; now, reverse the bytes:
	00100000 01000001 00000010 10111000

; store 0x02 into BRD_F @ *(r9+0x28)

	; move 0x02 into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r1 <= 0x02 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 0010 00000
	; 11010010 10000000 00000000 01000000
	; now, reverse the bytes:
	01000000 00000000 10000000 11010010

	; store r0 into *(r9+0x24)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0x28) <= r0
	; 1 0 1 1 1 0 0 0 0 0 0 0 0010 1000 0 0 01001 00000
	; 10111000 00000010 10000001 00100000
	; now, reverse the bytes:
	00100000 10000001 00000010 10111000

; enable FIFO and 8-bit data transmission

	; move 0000 0000 0111 0000 into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0000 0000 0111 0000 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0111 0000 00000
	; 11010010 10000000 00001110 00000000
	; now, reverse the bytes:
	00000000 00001110 10000000 11010010

	; store r0 into *(r9+0x2C)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0x2C) <= r0
	; 1 0 1 1 1 0 0 0 0 0 0 000101100 0 0 01001 00000
	; 10111000 00000010 11000001 00100000
	; now, reverse the bytes:
	00100000 11000001 00000010 10111000

; mask all interrupts

	; move 0000 0011 1111 0010 into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0000 0011 1111 0010 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0011 1111 0010 00000
	; 11010010 10000000 01111110 01000000
	; now, reverse the bytes:
	01000000 01111110 10000000 11010010

	; store r0 into *(r9+0x38)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0x38) <= r0
	; 1 0 1 1 1 0 0 0 0 0 0 000111000 0 0 01001 00000
	; 10111000 00000011 10000001 00100000
	; now, reverse the bytes:
	00100000 10000001 00000011 10111000

; enable UART, transfer, and receive

  ; 0x301
	; move 0000 0011 0000 0001 into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0000 0001 1000 0001 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0011 0000 0001 00000
	; 11010010 10000000 01100000 00100000
	; now, reverse the bytes:
	00100000 01100000 10000000 11010010

	; store r0 into *(r9+0x30)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0x30) <= r0
	; 1 0 1 1 1 0 0 0 0 0 0 000110000 0 0 01001 00000
	; 10111000 00000011 00000001 00100000
	; now, reverse the bytes:
	00100000 00000001 00000011 10111000

; wait for UART flags register *(r9+0x18) to say we're ready to write

	; move 0x20 (1<<5) into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0x10 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00000
	; 11010010 10000000 00000100 00000000
	; now, reverse the bytes:
	00000000 00000100 10000000 11010010

	; load *(r9+0x18) into r1
	; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
	; Rt <= *(Rn + imm)
	; r1 <= *(r9 + 0x18)
	; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
	; 11111000 01000001 10000001 00100001
	; now, reverse the bytes:
	00100001 10000001 01000001 11111000

	; check flag at bit index five
	; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
	; Rd <= Rn # Rm
	; r1 <= r1 & r0
	; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
	; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
	; 10001010 00000000 00000000 00100001
	; now, reverse the bytes:
	00100001 00000000 00000000 10001010

	; compare r1 to r0
	; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
	; Rn ? Rm
	; r1 ? r31
	; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
	; 11111010 01011111 11110000 00100000
	; now, reverse the bytes:
	00100000 11110000 01011111 11111010

	; if greater than, jump back three instructions
	; 0 1 0 1 0 1 0 0 imm19 0 cond4
	; imm = -2 ; cond = 1100
	; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
	; 01010100 11111111 11111111 10101100
	; now, reverse the bytes:
	10100001 11111111 11111111 01010100

; move 0x300100 into r11 (our memory address base)

	; move 0x30 << 16 into r11
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r11 <= 0x30 << 1*16
	; 1 1 0 1 0 0 1 0 1 01 0000 0000 0011 0000 01011
	; 11010010 10100000 00000110 00001011
	; now, reverse the bytes:
	00001011 00000110 10100000 11010010

	; add 0x100 to r11
	; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn + (uimm << (shift ? 12 : 0))
	; r11 <= r11 + (0x100 << (0 ? 12 : 0))
	; 1 0 0 1 0 0 0 1 0 0 0001 0000 0000 01011 01011
	; 10010001 00000100 00000001 01101011
	; now, reverse the bytes:
	01101011 00000001 00000100 10010001

; move r11 into r13 (our input address register)
; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Rn5 Rd5
; (Rd or *SP) <= (Rn or *SP)
; r13 <= r11
; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 01011 01101
; 10010001 00000000 00000001 01101101
; now, reverse the bytes:
01101101 00000001 00000000 10010001

; # read uartIn into memIn

	; wait for UART flags register *(r9+0x18) to say we're ready to read

		; move 0x10 (1<<4) into r0
		; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
		; Rd <= imm << hw*16
		; r0 <= 0x10 << 0*16
		; 1 1 0 1 0 0 1 0 1 00 0000 0000 0001 0000 00000
		; 11010010 10000000 00000010 00000000
		; now, reverse the bytes:
		00000000 00000010 10000000 11010010

		; load *(r9+0x18) into r1
		; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r1 <= *(r9 + 0x18)
		; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
		; 11111000 01000001 10000001 00100001
		; now, reverse the bytes:
		00100001 10000001 01000001 11111000

		; check flag at bit index four
		; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
		; Rd <= Rn # Rm
		; r1 <= r1 & r0
		; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
		; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
		; 10001010 00000000 00000000 00100001
		; now, reverse the bytes:
		00100001 00000000 00000000 10001010

		; compare r1 to r31
		; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
		; Rn ? Rm
		; r1 ? r31
		; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
		; 11111010 01011111 11110000 00100000
		; now, reverse the bytes:
		00100000 11110000 01011111 11111010

		; if greater than, jump back three instructions
		; 0 1 0 1 0 1 0 0 imm19 0 cond4
		; imm = -2 ; cond = 1100
		; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
		; 01010100 11111111 11111111 10101100
		; now, reverse the bytes:
		10101100 11111111 11111111 01010100

	; load *r9 into r2
	; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
	; Rt <= *(Rn + imm)
	; r2 <= *(r9 + 0)
	; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01001 00010
	; 00111001 01000000 00000001 00100010
	; now, reverse the bytes:
	00100010 00000001 01000000 00111001

	; store r2 into *r13
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r13 + 0) <= r2
	; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01101 00010
	; 10111000 00000000 00000001 10100010
	; now, reverse the bytes:
	10100010 00000001 00000000 10111000

	; add 0x1 to r13
	; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn + (uimm << (shift ? 12 : 0))
	; r13 <= r13 + (0x1 << (0 ? 12 : 0))
	; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01101 01101
	; 10010001 00000000 00000101 10101101
	; now, reverse the bytes:
	10101101 00000101 00000000 10010001

	; compare r2 to r31
	; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
	; Rn ? Rm
	; r2 ? r31
	; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00010 0 0 0 0 0
	; 11111010 01011111 11110000 01000000
	; now, reverse the bytes:
	01000000 11110000 01011111 11111010

	; if not equal, jump back 9 instructions
  ; 0 1 0 1 0 1 0 0 imm19 0 cond4
  ; imm = -9 ; cond = 0001
  ; 0 1 0 1 0 1 0 0 111 1111 1111 1111 0111 0 0001
  ; 01010100 11111111 11111110 11100001
  ; now, reverse the bytes:
  11100001 11111110 11111111 01010100

; # copy memIn to memOut

	; move r11 into r12
	; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Rn5 Rd5
  ; (Rd or *SP) <= (Rn or *SP)
  ; r12 <= r11
  ; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 01011 01100
  ; 10010001 00000000 00000001 01101100
  ; now, reverse the bytes:
  01101100 00000001 00000000 10010001

	; load *r12 into r2
  ; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
  ; Rt <= *(Rn + imm)
  ; r2 <= *(r12 + 0)
  ; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
  ; 00111001 01000000 00000001 10000010
  ; now, reverse the bytes:
  10000010 00000001 01000000 00111001

	; add 0x1 to r12
  ; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
  ; Rd <= Rn + (uimm << (shift ? 12 : 0))
  ; r12 <= r12 + (0x1 << (0 ? 12 : 0))
  ; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01100
  ; 10010001 00000000 00000101 10001100
  ; now, reverse the bytes:
  10001100 00000101 00000000 10010001

	; store r2 into *r13
  ; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
  ; *(Rn + imm) <= Rt
  ; *(r13 + 0) <= r2
  ; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01101 00010
  ; 10111000 00000000 00000001 10100010
  ; now, reverse the bytes:
  10100010 00000001 00000000 10111000

	; add 0x1 to r13
  ; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
  ; Rd <= Rn + (uimm << (shift ? 12 : 0))
  ; r13 <= r13 + (0x1 << (0 ? 12 : 0))
  ; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01101 01101
  ; 10010001 00000000 00000101 10101101
  ; now, reverse the bytes:
  10101101 00000101 00000000 10010001

	; compare r2 to r31
  ; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
  ; Rn ? Rm
  ; r2 ? r31
  ; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00010 0 0 0 0 0
  ; 11111010 01011111 11110000 01000000
  ; now, reverse the bytes:
  01000000 11110000 01011111 11111010

	; if not equal, jump back 5 intructions
  ; 0 1 0 1 0 1 0 0 imm19 0 cond4
  ; imm = -5 ; cond = 0001
  ; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1011 0 0001
  ; 01010100 11111111 11111111 01100001
  ; now, reverse the bytes:
  01100001 11111111 11111111 01010100

; # compute length of output

	; subtract r12 from r13, store into r14
	; 1 1 0 0 1 0 1 1 00 0 Rm5 000000 Rn5 Rd5
	; Rd <= Rn - Rm
	; r14 <= r13 - r12
	; 1 1 0 0 1 0 1 1 00 0 01100 000000 01101 01110
	; 11001011 00001100 00000001 10101110
	; now, reverse the bytes:
	10101110 00000001 00001100 11001011

	; subtract 1 from r14
	; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn - (uimm << (shift ? 12 : 0))
	; r12 <= r12 - (1 << (0 ? 12 : 0))
	; 1 1 0 1 0 0 0 1 0 0 0000 0000 0001 01110 01110
	; 11010001 00000000 00000101 11001110
	; now, reverse the bytes:
	11001110 00000101 00000000 11010001

; # print length in four bytes

	; move 0xff into r3
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
  ; Rd <= imm << hw*16
  ; r3 <= 0xff << 0*16
  ; 1 1 0 1 0 0 1 0 1 00 0000 0000 1111 1111 00011
  ; 11010010 10000000 00011111 11100011
  ; now, reverse the bytes:
  11100011 00011111 10000000 11010010
	
	; r2 <= r14 & (r3 << 24)
	; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
	; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
	; opc = 00 ; shift = 0 ; uimm = 24
	; r2 <= r14 & (r3 << 24)
	; 1 00 0 1 0 1 0 0 0 0 00011 011000 01110 00010
	; 10001010 00000011 01100001 11000010
	; now, reverse the bytes:
	11000010 01100001 00000011 10001010

	; r2 <= r31 | (r2 >> 24)
	; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
	; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
	; opc = 01 ; shift = 1 ; uimm = 24
	; r2 <= r32 | (r2 >> 24)
	; 1 01 0 1 0 1 0 0 1 0 00010 011000 11111 00010
	; 10101010 01000010 01100011 11100010
	; now, reverse the bytes:
	11100010 01100011 01000010 10101010

	; # print r2

		; move 0x20 (1<<5) into r0
		; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
		; Rd <= imm << hw*16
		; r0 <= 0x10 << 0*16
		; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00000
		; 11010010 10000000 00000100 00000000
		; now, reverse the bytes:
		00000000 00000100 10000000 11010010

		; load *(r9+0x18) into r1
		; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r1 <= *(r9 + 0x18)
		; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
		; 11111000 01000001 10000001 00100001
		; now, reverse the bytes:
		00100001 10000001 01000001 11111000

		; check flag at bit index five
		; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
		; Rd <= Rn # Rm
		; r1 <= r1 & r0
		; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
		; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
		; 10001010 00000000 00000000 00100001
		; now, reverse the bytes:
		00100001 00000000 00000000 10001010

		; compare r1 to r0
		; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
		; Rn ? Rm
		; r1 ? r31
		; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
		; 11111010 01011111 11110000 00100000
		; now, reverse the bytes:
		00100000 11110000 01011111 11111010

		; if greater than, jump back three instructions
		; 0 1 0 1 0 1 0 0 imm19 0 cond4
		; imm = -2 ; cond = 1100
		; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
		; 01010100 11111111 11111111 10101100
		; now, reverse the bytes:
		10100001 11111111 11111111 01010100

		; store r2 into *r9
		; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
		; *(Rn + imm) <= Rt
		; *(r9 + 0) <= r2
		; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01001 00010
		; 10111000 00000000 00000001 00100010
		; now, reverse the bytes:
		00100010 00000001 00000000 10111000
	
	; r2 <= r14 & (r3 << 16)
	; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
	; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
	; opc = 00 ; shift = 0 ; uimm = 16
	; r2 <= r14 & (r3 << 16)
	; 1 00 0 1 0 1 0 0 0 0 00011 010000 01110 00010
	; 10001010 00000011 01000001 11000010
	; now, reverse the bytes:
	11000010 01000001 00000011 10001010

	; r2 <= r31 | (r2 >> 16)
	; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
	; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
	; opc = 01 ; shift = 1 ; uimm = 16
	; r2 <= r32 | (r2 >> 16)
	; 1 01 0 1 0 1 0 0 1 0 00010 010000 11111 00010
	; 10101010 01000010 01000011 11100010
	; now, reverse the bytes:
	11100010 01000011 01000010 10101010

	; # print r2

		; move 0x20 (1<<5) into r0
		; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
		; Rd <= imm << hw*16
		; r0 <= 0x10 << 0*16
		; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00000
		; 11010010 10000000 00000100 00000000
		; now, reverse the bytes:
		00000000 00000100 10000000 11010010

		; load *(r9+0x18) into r1
		; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r1 <= *(r9 + 0x18)
		; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
		; 11111000 01000001 10000001 00100001
		; now, reverse the bytes:
		00100001 10000001 01000001 11111000

		; check flag at bit index five
		; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
		; Rd <= Rn # Rm
		; r1 <= r1 & r0
		; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
		; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
		; 10001010 00000000 00000000 00100001
		; now, reverse the bytes:
		00100001 00000000 00000000 10001010

		; compare r1 to r0
		; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
		; Rn ? Rm
		; r1 ? r31
		; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
		; 11111010 01011111 11110000 00100000
		; now, reverse the bytes:
		00100000 11110000 01011111 11111010

		; if greater than, jump back three instructions
		; 0 1 0 1 0 1 0 0 imm19 0 cond4
		; imm = -2 ; cond = 1100
		; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
		; 01010100 11111111 11111111 10101100
		; now, reverse the bytes:
		10100001 11111111 11111111 01010100

		; store r2 into *r9
		; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
		; *(Rn + imm) <= Rt
		; *(r9 + 0) <= r2
		; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01001 00010
		; 10111000 00000000 00000001 00100010
		; now, reverse the bytes:
		00100010 00000001 00000000 10111000
	
	; r2 <= r14 & (r3 << 8)
	; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
	; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
	; opc = 00 ; shift = 0 ; uimm = 8
	; r2 <= r14 & (r3 << 16)
	; 1 00 0 1 0 1 0 0 0 0 00011 001000 01110 00010
	; 10001010 00000011 00100001 11000010
	; now, reverse the bytes:
	11000010 00100001 00000011 10001010

	; r2 <= r31 | (r2 >> 8)
	; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
	; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
	; opc = 01 ; shift = 1 ; uimm = 8
	; r2 <= r32 | (r2 >> 8)
	; 1 01 0 1 0 1 0 0 1 0 00010 001000 11111 00010
	; 10101010 01000010 00100011 11100010
	; now, reverse the bytes:
	11100010 00100011 01000010 10101010

	; # print r2

		; move 0x20 (1<<5) into r0
		; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
		; Rd <= imm << hw*16
		; r0 <= 0x10 << 0*16
		; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00000
		; 11010010 10000000 00000100 00000000
		; now, reverse the bytes:
		00000000 00000100 10000000 11010010

		; load *(r9+0x18) into r1
		; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r1 <= *(r9 + 0x18)
		; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
		; 11111000 01000001 10000001 00100001
		; now, reverse the bytes:
		00100001 10000001 01000001 11111000

		; check flag at bit index five
		; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
		; Rd <= Rn # Rm
		; r1 <= r1 & r0
		; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
		; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
		; 10001010 00000000 00000000 00100001
		; now, reverse the bytes:
		00100001 00000000 00000000 10001010

		; compare r1 to r0
		; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
		; Rn ? Rm
		; r1 ? r31
		; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
		; 11111010 01011111 11110000 00100000
		; now, reverse the bytes:
		00100000 11110000 01011111 11111010

		; if greater than, jump back three instructions
		; 0 1 0 1 0 1 0 0 imm19 0 cond4
		; imm = -2 ; cond = 1100
		; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
		; 01010100 11111111 11111111 10101100
		; now, reverse the bytes:
		10100001 11111111 11111111 01010100

		; store r2 into *r9
		; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
		; *(Rn + imm) <= Rt
		; *(r9 + 0) <= r2
		; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01001 00010
		; 10111000 00000000 00000001 00100010
		; now, reverse the bytes:
		00100010 00000001 00000000 10111000
	
	; r2 <= r14 & r3
	; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
	; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
	; opc = 00 ; shift = 0 ; uimm = 0
	; r2 <= r14 & (r3 << 0)
	; 1 00 0 1 0 1 0 0 0 0 00011 000000 01110 00010
	; 10001010 00000011 00000001 11000010
	; now, reverse the bytes:
	11000010 00000001 00000011 10001010

	; # print r2

		; move 0x20 (1<<5) into r0
		; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
		; Rd <= imm << hw*16
		; r0 <= 0x10 << 0*16
		; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00000
		; 11010010 10000000 00000100 00000000
		; now, reverse the bytes:
		00000000 00000100 10000000 11010010

		; load *(r9+0x18) into r1
		; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r1 <= *(r9 + 0x18)
		; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
		; 11111000 01000001 10000001 00100001
		; now, reverse the bytes:
		00100001 10000001 01000001 11111000

		; check flag at bit index five
		; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
		; Rd <= Rn # Rm
		; r1 <= r1 & r0
		; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
		; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
		; 10001010 00000000 00000000 00100001
		; now, reverse the bytes:
		00100001 00000000 00000000 10001010

		; compare r1 to r0
		; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
		; Rn ? Rm
		; r1 ? r31
		; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
		; 11111010 01011111 11110000 00100000
		; now, reverse the bytes:
		00100000 11110000 01011111 11111010

		; if greater than, jump back three instructions
		; 0 1 0 1 0 1 0 0 imm19 0 cond4
		; imm = -2 ; cond = 1100
		; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
		; 01010100 11111111 11111111 10101100
		; now, reverse the bytes:
		10100001 11111111 11111111 01010100

		; store r2 into *r9
		; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
		; *(Rn + imm) <= Rt
		; *(r9 + 0) <= r2
		; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01001 00010
		; 10111000 00000000 00000001 00100010
		; now, reverse the bytes:
		00100010 00000001 00000000 10111000

; # print memOut to uartOut

  ; load *r12 into r2
  ; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
  ; Rt <= *(Rn + imm)
  ; r2 <= *(r12 + 0)
  ; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
  ; 00111001 01000000 00000001 10000010
  ; now, reverse the bytes:
  10000010 00000001 01000000 00111001

  ; add 0x1 to r12
  ; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
  ; Rd <= Rn + (uimm << (shift ? 12 : 0))
  ; r12 <= r12 + (0x1 << (0 ? 12 : 0))
  ; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01100
  ; 10010001 00000000 00000101 10001100
  ; now, reverse the bytes:
  10001100 00000101 00000000 10010001

	; # wait for UART flags register *(r9+0x18) to say we're ready to write

		; move 0x20 (1<<5) into r0
		; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
		; Rd <= imm << hw*16
		; r0 <= 0x10 << 0*16
		; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00000
		; 11010010 10000000 00000100 00000000
		; now, reverse the bytes:
		00000000 00000100 10000000 11010010

		; load *(r9+0x18) into r1
		; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r1 <= *(r9 + 0x18)
		; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
		; 11111000 01000001 10000001 00100001
		; now, reverse the bytes:
		00100001 10000001 01000001 11111000

		; check flag at bit index five
		; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
		; Rd <= Rn # Rm
		; r1 <= r1 & r0
		; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
		; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
		; 10001010 00000000 00000000 00100001
		; now, reverse the bytes:
		00100001 00000000 00000000 10001010

		; compare r1 to r0
		; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
		; Rn ? Rm
		; r1 ? r31
		; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
		; 11111010 01011111 11110000 00100000
		; now, reverse the bytes:
		00100000 11110000 01011111 11111010

		; if greater than, jump back three instructions
		; 0 1 0 1 0 1 0 0 imm19 0 cond4
		; imm = -2 ; cond = 1100
		; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
		; 01010100 11111111 11111111 10101100
		; now, reverse the bytes:
		10100001 11111111 11111111 01010100

		; store r2 into *r9
		; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
		; *(Rn + imm) <= Rt
		; *(r9 + 0) <= r2
		; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01001 00010
		; 10111000 00000000 00000001 00100010
		; now, reverse the bytes:
		00100010 00000001 00000000 10111000

	; subtract 0x1 from r3

	; FIXME compare r3 to r31
  ; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
  ; Rn ? Rm
  ; r2 ? r31
  ; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00010 0 0 0 0 0
  ; 11111010 01011111 11110000 01000000
  ; now, reverse the bytes:
  01000000 11110000 01011111 11111010

	; if not equal, jump back 9 instructions
  ; 0 1 0 1 0 1 0 0 imm19 0 cond4
  ; imm = -9 ; cond = 0001
  ; 0 1 0 1 0 1 0 0 111 1111 1111 1111 0111 0 0001
  ; 01010100 11111111 11111110 11100001
  ; now, reverse the bytes:
  11100001 11111110 11111111 01010100
