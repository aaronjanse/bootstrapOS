; XXXXX move 0x79 into r3
; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
; Rd <= imm << hw*16
; r3 <= 0x79 << 0*16
; 1 1 0 1 0 0 1 0 1 00 0000 0000 0111 1001 00011
; 11010010 10000000 00001111 00100011
; now, reverse the bytes:
00100011 00001111 10000000 11010010



; move 0xFE200000 into r8 and 0xFE201000 into r9

	; move 0xFE20 << 16 into r8
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r8 <= 0xFE20 << 1*16
	; 1 1 0 1 0 0 1 0 1 01 1111 1110 0010 0000 01000
	; 11010010 10111111 11000100 00001000
	; now, reverse the bytes:
	00001000 11000100 10111111 11010010

	; add 0x1000 to r8 to move 0xFE201000 into r9
	; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn + (uimm << (shift ? 12 : 0))
	; r9 <= r8 + (0x1 << (1 ? 12 : 0))
	; 1 0 0 1 0 0 0 1 0 1 0000 0000 0001 01000 01001
	; 10010001 01000000 00000101 00001001
	; now, reverse the bytes:
	00001001 00000101 01000000 10010001

; disable UART

	; store 0x0 into *(r9+0x30)
	; 1 1 1 1 1 0 0 0 0 0 0 imm9 1 1 Rn5 Rt5
	; *(Rt + imm) <= Rn
	; *(r9 + 0x30) <= r31
	; 1 1 1 1 1 0 0 0 0 0 0 000110000 1 1 11111 01001
	; 11111000 00000011 00001111 11101001
	; now, reverse the bytes:
	;;;;;; 11101001 00001111 00000011 11111000

; disable GPIO pin pull up/down

	; store 0x0 into *(r8+0x94)
	; 1 1 1 1 1 0 0 0 0 0 0 imm9 1 1 Rn5 Rt5
	; *(Rt + imm) <= Rn
	; *(r8 + 0x94) <= r31
	; 1 1 1 1 1 0 0 0 0 0 0 010010100 1 1 11111 01000
	; 11111000 00001001 01001111 11101000
	; now, reverse the bytes:
	;;;;;; 11101000 01001111 00001001 11111000

; delay for 150 cycles

	; move 150 (0x96) into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0x96 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0111 1000 00000
	; 11010010 10000000 00001111 00000000
	; now, reverse the bytes:
	00000000 00001111 10000000 11010010

	; subtract 1 from r0
	; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn - (uimm << (shift ? 12 : 0))
	; r0 <= r0 - (1 << (0 ? 12 : 0))
	; 1 1 0 1 0 0 0 1 0 0 0000 0000 0001 00000 00000
	; 11010001 00000000 00000100 00000000
	; now, reverse the bytes:
	00000000 00000100 00000000 11010001

	; compare r0 to r31
	; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
	; Rn ? Rm
	; r0 ? r31
	; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00000 0 0 0 0 0
	; 11111010 01011111 11110000 00000000
	; now, reverse the bytes:
	00000000 11110000 01011111 11111010

	; if greater than, jump back two instructions
	; 0 1 0 1 0 1 0 0 imm19 0 cond4
	; imm = -2 ; cond = 1100
	; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1110 0 1100
	; 01010100 11111111 11111111 11001100
	; now, reverse the bytes:
	11000000 11111111 11111111 01010100

; disable GPIO pin pull up/down clock 0

	; store 0x0 into *(r8+0x98)
	; 1 1 1 1 1 0 0 1 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r8 + 0x98) <= r31
	; 1 1 1 1 1 0 0 1 0 0 0 010011000 0 0 01000 11111
	; 11111001 00001001 10000001 00011111
	; now, reverse the bytes:
	00011111 10000001 00001001 11111001


; delay for 150 cycles

	; move 150 (0x96) into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0x96 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 1001 0110 00000
	; 11010010 10000000 00010010 11000000
	; now, reverse the bytes:
	11000000 00010010 10000000 11010010

	; subtract 1 from r0
	; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn - (uimm << (shift ? 12 : 0))
	; r0 <= r0 - (1 << (0 ? 12 : 0))
	; 1 1 0 1 0 0 0 1 0 0 0000 0000 0001 00000 00000
	; 11010001 00000000 00000100 00000000
	; now, reverse the bytes:
	00000000 00000100 00000000 11010001

	; compare r0 to r31
	; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
	; Rn ? Rm
	; r0 ? r31
	; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00000 0 0 0 0 0
	; 11111010 01011111 11110000 00000000
	; now, reverse the bytes:
	00000000 11110000 01011111 11111010

	; if greater than, jump back two instructions
	; 0 1 0 1 0 1 0 0 imm19 0 cond4
	; imm = -2 ; cond = 1100
	; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1110 0 1100
	; 01010100 11111111 11111111 11001100
	; now, reverse the bytes:
	11001100 11111111 11111111 01010100




; disable GPIO pin pull up/down clock 0
; store 0x0 into *(r8+0x98)

; clear all pending interrupts
; store 0x0 into *(r9+0x1044)

; set baud rate to 115200 given a ? Mhz clock
; NVM, experimentally derived from c3r3s, ignore the following calculations
; BDR = (3 000 000)/(16 * 115200) = 1.6276
; BDR_F = 0.6276
; BDR_I = 1 = 0x1
; m = int((0.6276*64)+0.5) = 40 = 0x28



; store 0x1a into BRD_I @ *(r9+0x24)

	; move 0x1a into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0x1a << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0001 1010 00000
	; 11010010 10000000 00000011 01000000
	; now, reverse the bytes:
	01000000 00000011 10000000 11010010


	; store r0 into *(r9+0x24)
	; 1 1 1 1 1 0 0 0 0 0 0 imm9 1 1 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0x24) <= r0
	; 1 1 1 1 1 0 0 0 0 0 0 0 0010 0100 1 1 01001 00000
	; 11111000 00000010 01001101 00100000
	; now, reverse the bytes:
	;;;;;;;; 00100000 01001101 00000010 11111000







; store 0x02 into BRD_F @ *(r9+0x28)

	; move 0x02 into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r1 <= 0x02 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 0010 00000
	; 11010010 10000000 00000000 01000000
	; now, reverse the bytes:
	01000000 00000000 10000000 11010010

	; store r0 into *(r9+0x24)
	; 1 1 1 1 1 0 0 0 0 0 0 imm9 1 1 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0x28) <= r0
	; 1 1 1 1 1 0 0 0 0 0 0 0 0010 1000 1 1 01001 00000
	; 11111000 00000010 10001101 00100000
	; now, reverse the bytes:
	;;;;;; 00100000 10001101 00000010 11111000


; enable FIFO and 8-bit data transmission
; store 0111 0000 into *(r9+0x2C)

; mask all interrupts
; store 11 1111 0010 into *(r9+0x38)

; enable UART, transfer, and receive
; store 000 0001 1000 0001 into *(r9+0x30)



; wait for UART flags register *(r9+0x18) to say we're ready to read

	; move 0x10 (1<<4) into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0x10 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0001 0000 00000
	; 11010010 10000000 00000010 00000000
	; now, reverse the bytes:
	00000000 00000010 10000000 11010010

	; load *(r9+0x18) into r1
	; 1 1 1 1 1 0 0 1 0 0 uimm12 Rn5 Rt5
	; Rt <= *(Rn + uimm*8)
	; r1 <= *(r9 + 0x18)
	; 1 1 1 1 1 0 0 1 0 1 0 000000001 1 0 01001 00001
	; 11111001 01000000 00011001 00100001
	; now, reverse the bytes:
	00100001 00001101 01000000 11111001

	; check flag at bit index four
	; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
	; Rd <= Rn # Rm
	; r1 <= r1 & r0
	; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
	; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
	; 10001010 00000000 00000000 00100001
	; now, reverse the bytes:
	00100001 00000000 00000000 10001010

	; compare r1 to r0
	; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
	; Rn ? Rm
	; r1 ? r31
	; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
	; 11111010 01011111 11110000 00100000
	; now, reverse the bytes:
	00100000 11110000 01011111 11111010

	; if greater than, jump back three instructions
	; 0 1 0 1 0 1 0 0 imm19 0 cond4
	; imm = -2 ; cond = 1100
	; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
	; 01010100 11111111 11111111 10101100
	; now, reverse the bytes:
	10101100 11111111 11111111 01010100

; load *r9 into r0
; 1 1 1 1 1 0 0 1 0 1 uimm12 Rn5 Rt5
; Rt <= *(Rn + uimm*8)
; r0 <= *(r9 + 0*0)
; 1 1 1 1 1 0 0 1 0 1 000000000000 01001 00000
; 11111001 01000000 00000001 00100000
; now, reverse the bytes:
00100000 00000001 01000000 11111001

; write 'x' to UART

	; move 0x78 into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0x78 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0111 1000 00000
	; 11010010 10000000 00001111 00000000
	; now, reverse the bytes:
	; 00000000 00001111 10000000 11010010

	; store r0 into *r9
	; 1 1 1 1 1 0 0 0 0 0 0 imm9 1 1 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0) <= r0
	; 1 1 1 1 1 0 0 0 0 0 0 000000000 1 1 01001 00000
	; 11111000 00000000 00001101 00100000
	; now, reverse the bytes:
	00100000 00001101 00000000 11111000



; jump back seven instructions
; 0 1 0 1 0 1 0 0 imm19 0 cond4
; imm = -2 ; cond = 1111
; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1001 0 1100
; 01010100 11111111 11111111 10101100
; now, reverse the bytes:
001 01111 11111111 11111111 01010100




; jump back seven instructions

; read into r3

; wait for UART flags register *(r9+0x18) to say we're ready to write

; store r3 into *(r9+0)
