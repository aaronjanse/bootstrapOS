; - setup UART
; - read UART to memory
; - read non-commented 1s and 0s to memory
; - print memory

; move 0xFE200000 into r8 and 0xFE201000 into r9

	; move 0xFE20 << 16 into r8
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r8 <= 0xFE20 << 1*16
	; 1 1 0 1 0 0 1 0 1 01 1111 1110 0010 0000 01000
	11010010 10111111 11000100 00001000

	; add 0x1000 to r8 to move 0xFE201000 into r9
	; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn + (uimm << (shift ? 12 : 0))
	; r9 <= r8 + (0x1 << (1 ? 12 : 0))
	; 1 0 0 1 0 0 0 1 0 1 0000 0000 0001 01000 01001
	10010001 01000000 00000101 00001001

; disable UART

	; store 0x0 into *(r9+0x30)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0x30) <= r31
	; 1 0 1 1 1 0 0 0 0 0 0 000110000 0 0 01001 11111
	10111000 00000011 00000001 00111111

; disable GPIO pin pull up/down

	; store 0x0 into *(r8+0x94)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r8 + 0x94) <= r31
	; 1 0 1 1 1 0 0 0 0 0 0 010010100 0 0 01000 11111
	10111000 00001001 01000001 00011111

; delay for 150 cycles

	; move 150 (0x96) into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0x96 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0111 1000 00000
	11010010 10000000 00010010 11000000

	; subtract 1 from r0
	; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn - (uimm << (shift ? 12 : 0))
	; r0 <= r0 - (1 << (0 ? 12 : 0))
	; 1 1 0 1 0 0 0 1 0 0 0000 0000 0001 00000 00000
	11010001 00000000 00000100 00000000

	; compare r0 to r31
	; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
	; Rn ? Rm
	; r0 ? r31
	; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00000 0 0 0 0 0
	11111010 01011111 11110000 00000000

	; if greater than, jump back two instructions
	; 0 1 0 1 0 1 0 0 imm19 0 cond4
	; imm = -2 ; cond = 1100
	; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1110 0 1100
	01010100 11111111 11111111 11001100

; ahhhhhhhhhhhhhhhh

	; move 1100 0000 0000 0000 into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 1100 0000 0000 0000 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 1100 0000 0000 0000 00000
	11010010 10011000 00000000 00000000

	; store r0 into GPIO clock 0
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r8 + 0x98) <= r0
	; 1 0 1 1 1 0 0 0 0 0 0 010011000 0 0 01000 00000
	10111000 00001001 10000001 00000000

; disable GPIO pin pull up/down clock 1

	; store 0x0 into *(r8+0x9C)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r8 + 0x9C) <= r31
	; 1 0 1 1 1 0 0 0 0 0 0 010011100 0 0 01000 11111
	10111000 00001001 11000001 00011111

; delay for 150 cycles

	; move 150 (0x96) into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0x96 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 1001 0110 00000
	11010010 10000000 00010010 11000000

	; subtract 1 from r0
	; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn - (uimm << (shift ? 12 : 0))
	; r0 <= r0 - (1 << (0 ? 12 : 0))
	; 1 1 0 1 0 0 0 1 0 0 0000 0000 0001 00000 00000
	11010001 00000000 00000100 00000000

	; compare r0 to r31
	; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
	; Rn ? Rm
	; r0 ? r31
	; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00000 0 0 0 0 0
	11111010 01011111 11110000 00000000

	; if greater than, jump back two instructions
	; 0 1 0 1 0 1 0 0 imm19 0 cond4
	; imm = -2 ; cond = 1100
	; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1110 0 1100
	01010100 11111111 11111111 11001100

; disable GPIO pin pull up/down clock 0

	; store 0x0 into *(r8+0x98)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r8 + 0x98) <= r31
	; 1 0 1 1 1 0 0 0 0 0 0 010011000 0 0 01000 11111
	10111000 00001001 10000001 00011111

; disable GPIO pin pull up/down clock 1

	; store 0x0 into *(r8+0x9C)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r8 + 0x9C) <= r31
	; 1 0 1 1 1 0 0 0 0 0 0 010011100 0 0 01000 11111
	10111000 00001001 11000001 00011111

; clear all pending interrupts

	; move 0x7ff into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0x7ff << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0111 1111 1111 00000
	11010010 10000000 11111111 11100000

	; store r0 into *(r9+0x44)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0x44) <= r0
	; 1 0 1 1 1 0 0 0 0 0 0 001000100 0 0 01001 00000
	10111000 00000100 01000001 00100000

; set baud rate to 115200 given a ? Mhz clock
; NVM, experimentally derived from c3r3s, ignore the following calculations
; AHHH BDR = (3 000 000)/(16 * 115200) = 1.6276
; AHHH BDR_F = 0.6276
; AHHH BDR_I = 1 = 0x1
; AHHH m = int((0.6276*64)+0.5) = 40 = 0x28

; store 0x1a into BRD_I @ *(r9+0x24)

	; move 0x1a into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0x1a << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0001 1010 00000
	11010010 10000000 00000011 01000000

	; store r0 into *(r9+0x24)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0x24) <= r0
	; 1 0 1 1 1 0 0 0 0 0 0 0 0010 0100 0 0 01001 00000
	10111000 00000010 01000001 00100000

; store 0x02 into BRD_F @ *(r9+0x28)

	; move 0x02 into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r1 <= 0x02 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 0010 00000
	11010010 10000000 00000000 01000000

	; store r0 into *(r9+0x24)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0x28) <= r0
	; 1 0 1 1 1 0 0 0 0 0 0 0 0010 1000 0 0 01001 00000
	10111000 00000010 10000001 00100000

; enable FIFO and 8-bit data transmission

	; move 0000 0000 0111 0000 into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0000 0000 0111 0000 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0111 0000 00000
	11010010 10000000 00001110 00000000

	; store r0 into *(r9+0x2C)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0x2C) <= r0
	; 1 0 1 1 1 0 0 0 0 0 0 000101100 0 0 01001 00000
	10111000 00000010 11000001 00100000

; mask all interrupts

	; move 0000 0011 1111 0010 into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0000 0011 1111 0010 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0011 1111 0010 00000
	11010010 10000000 01111110 01000000

	; store r0 into *(r9+0x38)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0x38) <= r0
	; 1 0 1 1 1 0 0 0 0 0 0 000111000 0 0 01001 00000
	10111000 00000011 10000001 00100000

; enable UART, transfer, and receive

	; 0x301
	; move 0000 0011 0000 0001 into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0000 0001 1000 0001 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0011 0000 0001 00000
	11010010 10000000 01100000 00100000

	; store r0 into *(r9+0x30)
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r9 + 0x30) <= r0
	; 1 0 1 1 1 0 0 0 0 0 0 000110000 0 0 01001 00000
	10111000 00000011 00000001 00100000

; wait for UART flags register *(r9+0x18) to say we're ready to write

	; move 0x20 (1<<5) into r0
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r0 <= 0x10 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00000
	11010010 10000000 00000100 00000000

	; load *(r9+0x18) into r1
	; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
	; Rt <= *(Rn + imm)
	; r1 <= *(r9 + 0x18)
	; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
	11111000 01000001 10000001 00100001

	; check flag at bit index five
	; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
	; Rd <= Rn # Rm
	; r1 <= r1 & r0
	; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
	; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
	10001010 00000000 00000000 00100001

	; compare r1 to r0
	; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
	; Rn ? Rm
	; r1 ? r31
	; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
	11111010 01011111 11110000 00100000

	; if greater than, jump back three instructions
	; 0 1 0 1 0 1 0 0 imm19 0 cond4
	; imm = -2 ; cond = 1100
	; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
	01010100 11111111 11111111 10100001

; move 0x300100 into r11 (our memory address base)

	; move 0x30 << 16 into r11
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r11 <= 0x30 << 1*16
	; 1 1 0 1 0 0 1 0 1 01 0000 0000 0011 0000 01011
	11010010 10100000 00000110 00001011

	; add 0x100 to r11
	; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn + (uimm << (shift ? 12 : 0))
	; r11 <= r11 + (0x100 << (0 ? 12 : 0))
	; 1 0 0 1 0 0 0 1 0 0 0001 0000 0000 01011 01011
	10010001 00000100 00000001 01101011

; move r11 into r13 (our input address register)
; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Rn5 Rd5
; (Rd or *SP) <= (Rn or *SP)
; r13 <= r11
; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 01011 01101
10010001 00000000 00000001 01101101

; # read uartIn into memIn

	; wait for UART flags register *(r9+0x18) to say we're ready to read

		; move 0x10 (1<<4) into r0
		; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
		; Rd <= imm << hw*16
		; r0 <= 0x10 << 0*16
		; 1 1 0 1 0 0 1 0 1 00 0000 0000 0001 0000 00000
		11010010 10000000 00000010 00000000

		; load *(r9+0x18) into r1
		; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r1 <= *(r9 + 0x18)
		; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
		11111000 01000001 10000001 00100001

		; check flag at bit index four
		; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
		; Rd <= Rn # Rm
		; r1 <= r1 & r0
		; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
		; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
		10001010 00000000 00000000 00100001

		; compare r1 to r31
		; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
		; Rn ? Rm
		; r1 ? r31
		; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
		11111010 01011111 11110000 00100000

		; if greater than, jump back three instructions
		; 0 1 0 1 0 1 0 0 imm19 0 cond4
		; imm = -2 ; cond = 1100
		; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
		01010100 11111111 11111111 10101100

	; load *r9 into r2
	; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
	; Rt <= *(Rn + imm)
	; r2 <= *(r9 + 0)
	; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01001 00010
	00111001 01000000 00000001 00100010

	; store r2 into *r13
	; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
	; *(Rn + imm) <= Rt
	; *(r13 + 0) <= r2
	; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01101 00010
	10111000 00000000 00000001 10100010

	; add 0x1 to r13
	; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn + (uimm << (shift ? 12 : 0))
	; r13 <= r13 + (0x1 << (0 ? 12 : 0))
	; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01101 01101
	10010001 00000000 00000101 10101101

	; compare r2 to r31
	; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
	; Rn ? Rm
	; r2 ? r31
	; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00010 0 0 0 0 0
	11111010 01011111 11110000 01000000

	; if not equal, jump back 9 instructions
	; 0 1 0 1 0 1 0 0 imm19 0 cond4
	; imm = -9 ; cond = 0001
	; 0 1 0 1 0 1 0 0 111 1111 1111 1111 0111 0 0001
	01010100 11111111 11111110 11100001

; move r11 into r12
; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Rn5 Rd5
; (Rd or *SP) <= (Rn or *SP)
; r12 <= r11
; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 01011 01100
10010001 00000000 00000001 01101100

; # slurp whitespace and comments

  ; # slurp whitespace

		; load *r12 into r2
		; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r2 <= *(r12 + 0)
		; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
		00111001 01000000 00000001 10000010

		; add 0x1 to r12
		; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
		; Rd <= Rn + (uimm << (shift ? 12 : 0))
		; r12 <= r12 + (0x1 << (0 ? 12 : 0))
		; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01100
		10010001 00000000 00000101 10001100

		; # ' '

			; set r1 to ' ' (0x20)
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r2 <= 0x21 << 0*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00001
			11010010 10000000 00000100 00000001

			; compare r1 to r2
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r1 ? r2
			; 1 1 1 1 1 0 1 0 0 1 0 00010 1 1 1 1 0 0 00001 0 0 0 0 0
			11111010 01000010 11110000 00100000

			; if equal, jump back 4 instructions to beginning of loop
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = -4 ; cond = 0000
			; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1100 0 0000
			01010100 11111111 11111111 10000000

		; # '\t'

			; set r1 to '\t' (9)
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r2 <= 0x21 << 0*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 1001 00001
			11010010 10000000 00000001 00100001

			; compare r1 to r2
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r1 ? r2
			; 1 1 1 1 1 0 1 0 0 1 0 00010 1 1 1 1 0 0 00001 0 0 0 0 0
			11111010 01000010 11110000 00100000

			; if equal, jump back 7 instructions to beginning of loop
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = -7 ; cond = 0000
			; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1001 0 0000
			01010100 11111111 11111111 00100000

		; # '\n' (blank line)

			; set r1 to '\n' (10)
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r2 <= 0x21 << 0*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 1010 00001
			11010010 10000000 00000001 01000001

			; compare r1 to r2
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r1 ? r2
			; 1 1 1 1 1 0 1 0 0 1 0 00010 1 1 1 1 0 0 00001 0 0 0 0 0
			11111010 01000010 11110000 00100000

			; if equal, jump back 10 instructions to beginning of loop
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = -10 ; cond = 0000
			; 0 1 0 1 0 1 0 0 111 1111 1111 1111 0110 0 0000
			01010100 11111111 11111110 11000000

		; # move back head since we didn't find whitespace

			; subtract 1 from r12
			; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
			; Rd <= Rn - (uimm << (shift ? 12 : 0))
			; r12 <= r12 - (1 << (0 ? 12 : 0))
			; 1 1 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01110
			11010001 00000000 00000101 10001100

  ; # handle comments

		; load *r12 into r2
		; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r2 <= *(r12 + 0)
		; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
		00111001 01000000 00000001 10000010

		; set r1 to ';' (0x3b)
		; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
		; Rd <= imm << hw*16
		; r2 <= 0x21 << 0*16
		; 1 1 0 1 0 0 1 0 1 00 0000 0000 0011 1011 00001
		11010010 10000000 00000111 01100001

		; compare r1 to r2
		; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
		; Rn ? Rm
		; r1 ? r2
		; 1 1 1 1 1 0 1 0 0 1 0 00010 1 1 1 1 0 0 00001 0 0 0 0 0
		11111010 01000010 11110000 00100000

		; if not equal, jump forward 7 instructions past comment-slurping routine
		; 0 1 0 1 0 1 0 0 imm19 0 cond4
		; imm = 7 ; cond = 0001
		; 0 1 0 1 0 1 0 0 000 0000 0000 0000 0111 0 0001
		01010100 00000000 00000000 11100001

		; # slurp comment contents

			; load *r12 into r2
			; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
			; Rt <= *(Rn + imm)
			; r2 <= *(r12 + 0)
			; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
			00111001 01000000 00000001 10000010

			; add 0x1 to r12
			; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
			; Rd <= Rn + (uimm << (shift ? 12 : 0))
			; r12 <= r12 + (0x1 << (0 ? 12 : 0))
			; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01100
			10010001 00000000 00000101 10001100

			; set r1 to '\n' (10)
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r2 <= 0x21 << 0*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 1010 00001
			11010010 10000000 00000001 01000001

			; compare r1 to r2
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r1 ? r2
			; 1 1 1 1 1 0 1 0 0 1 0 00010 1 1 1 1 0 0 00001 0 0 0 0 0
			11111010 01000010 11110000 00100000

			; if not equal, jump back 4 instructions to beginning of slurp loop
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = -4 ; cond = 0001
			; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1100 0 0001
			01010100 11111111 11111111 10000001

			; jump back 21 instructions to code for beginning of line
			; 0 0 0 1 0 1 imm26
			; 0 0 0 1 0 1 11 1111 1111 1111 1111 1110 1011
			00010111 11111111 11111111 11101011

	; # check for null byte

		; load *r12 into r2
		; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r2 <= *(r12 + 0)
		; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
		00111001 01000000 00000001 10000010

		; compare r2 to r31
		; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
		; Rn ? Rm
		; r2 ? r31
		; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00010 0 0 0 0 0
		11111010 01011111 11110000 01000000

		; if equal, jump forward 9 instructions past end of phase
		; 0 1 0 1 0 1 0 0 imm19 0 cond4
		; imm = -5 ; cond = 0001
		; 0 1 0 1 0 1 0 0 000 0000 0000 0000 1001 0 0000
		01010100 00000000 00000001 00100000

  ; # copy all other code verbatim

		; load *r12 into r2
		; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r2 <= *(r12 + 0)
		; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
		00111001 01000000 00000001 10000010

		; add 0x1 to r12
		; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
		; Rd <= Rn + (uimm << (shift ? 12 : 0))
		; r12 <= r12 + (0x1 << (0 ? 12 : 0))
		; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01100
		10010001 00000000 00000101 10001100

		; set r1 to '\n' (10)
		; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
		; Rd <= imm << hw*16
		; r2 <= 0x21 << 0*16
		; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 1010 00001
		11010010 10000000 00000001 01000001

		; compare r1 to r2
		; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
		; Rn ? Rm
		; r1 ? r2
		; 1 1 1 1 1 0 1 0 0 1 0 00010 1 1 1 1 0 0 00001 0 0 0 0 0
		11111010 01000010 11110000 00100000

		; if equal, jump back 29 instructions to code for beginning of line
		; 0 1 0 1 0 1 0 0 imm19 0 cond4
		; imm = -27 ; cond = 0001
		; 0 1 0 1 0 1 0 0 111 1111 1111 1110 0011 0 0000
		01010100 11111111 11111100 01100000

		; # copy character to memOut

			; store r2 into *r13
			; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
			; *(Rn + imm) <= Rt
			; *(r13 + 0) <= r2
			; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01101 00010
			10111000 00000000 00000001 10100010

			; add 0x1 to r13
			; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
			; Rd <= Rn + (uimm << (shift ? 12 : 0))
			; r13 <= r13 + (0x1 << (0 ? 12 : 0))
			; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01101 01101
			10010001 00000000 00000101 10101101

			; jump back 7 instructions to beginning of verbatim-handling loop
			; 0 0 0 1 0 1 imm26
			; 0 0 0 1 0 1 11 1111 1111 1111 1111 1111 1001
			00010111 11111111 11111111 11111001

	; # move r12 head past null byte

		; add 0x1 to r12
		; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
		; Rd <= Rn + (uimm << (shift ? 12 : 0))
		; r12 <= r12 + (0x1 << (0 ? 12 : 0))
		; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01100
		10010001 00000000 00000101 10001100


  ; # copy memOut to memIn

  	; # make r13 at memIn, r12 is already at memOut

  		; copy r11 to r13
			; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Rn5 Rd5
			; (Rd or *SP) <= (Rn or *SP)
			; r13 <= r11
			; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 01011 01101
			10010001 00000000 00000001 01101101

		; load *r12 into r2
		; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r2 <= *(r12 + 0)
		; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
		00111001 01000000 00000001 10000010

		; add 0x1 to r12
		; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
		; Rd <= Rn + (uimm << (shift ? 12 : 0))
		; r12 <= r12 + (0x1 << (0 ? 12 : 0))
		; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01100
		10010001 00000000 00000101 10001100

		; store byte r2 into *r13
		; 0 0 1 1 1 0 0 1 0 0 imm12 Rn5 Rt5
		; *(Rn + imm) <= Rt
		; *(r13 + 0) <= r2
		; 0 0 1 1 1 0 0 1 0 0 0000 0000 0000 01101 00010
		00111001 00000000 00000001 10100010

		; add 0x1 to r13
		; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
		; Rd <= Rn + (uimm << (shift ? 12 : 0))
		; r13 <= r13 + (0x1 << (0 ? 12 : 0))
		; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01101 01101
		10010001 00000000 00000101 10101101

		; compare r2 to r31
		; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
		; Rn ? Rm
		; r2 ? r31
		; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00010 0 0 0 0 0
		11111010 01011111 11110000 01000000

		; if not equal, jump back 5 instructions
		; 0 1 0 1 0 1 0 0 imm19 0 cond4
		; imm = -5 ; cond = 0001
		; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1011 0 0001
		01010100 11111111 11111111 01100001

	; # make r12 at memIn, r13 is already at memOut

		; copy r11 to r12
		; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Rn5 Rd5
		; (Rd or *SP) <= (Rn or *SP)
		; r12 <= r11
		; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 01011 01100
		10010001 00000000 00000001 01101100

; # parse machine code & basic assembly instructions

	; set r3 to 32
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r2 <= 32 << 8*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00011
	11010010 10000000 00000100 00000011

	; # copy $r3 ascii bits from memIn to memOut

		; load *r12 into r2
		; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r2 <= *(r12 + 0)
		; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
		00111001 01000000 00000001 10000010

		; add 0x1 to r12
		; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
		; Rd <= Rn + (uimm << (shift ? 12 : 0))
		; r12 <= r12 + (0x1 << (0 ? 12 : 0))
		; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01100
		10010001 00000000 00000101 10001100

		; # skip whitespace

			; set r1 to ' ' (0x20)
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r2 <= 0x21 << 0*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00001
			11010010 10000000 00000100 00000001

			; compare r1 to r2
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r1 ? r2
			; 1 1 1 1 1 0 1 0 0 1 0 00010 1 1 1 1 0 0 00001 0 0 0 0 0
			11111010 01000010 11110000 00100000

			; if equal, jump back 4 instructions to beginning of loop
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = -4 ; cond = 0000
			; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1100 0 0000
			01010100 11111111 11111111 10000000

			; set r1 to '\t' (9)
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r2 <= 0x21 << 0*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 1001 00001
			11010010 10000000 00000001 00100001

			; compare r1 to r2
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r1 ? r2
			; 1 1 1 1 1 0 1 0 0 1 0 00010 1 1 1 1 0 0 00001 0 0 0 0 0
			11111010 01000010 11110000 00100000

			; if equal, jump back 7 instructions to beginning of loop
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = -7 ; cond = 0000
			; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1001 0 0000
			01010100 11111111 11111111 00100000

		; # handle ascii bits

			; set r1 to '0' (0x30)
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r1 <= 0x30 << 0*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0011 0000 00001
			11010010 10000000 00000110 00000001

			; compare r1 to r2
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r1 ? r2
			; 1 1 1 1 1 0 1 0 0 1 0 00010 1 1 1 1 0 0 00001 0 0 0 0 0
			11111010 01000010 11110000 00100000

			; if equal, jump forward 5 instructions to ascii bit routine
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = 5 ; cond = 0000
			; 0 1 0 1 0 1 0 0 000 0000 0000 0000 0101 0 0000
			01010100 00000000 00000000 10100000

			; set r1 to '1' (0x31)
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r2 <= 0x21 << 0*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0011 0001 00001
			11010010 10000000 00000110 00100001

			; compare r1 to r2
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r1 ? r2
			; 1 1 1 1 1 0 1 0 0 1 0 00010 1 1 1 1 0 0 00001 0 0 0 0 0
			11111010 01000010 11110000 00100000

			; if equal, jump forward 2 instructions to ascii bit routine
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = 2 ; cond = 0000
			; 0 1 0 1 0 1 0 0 000 0000 0000 0000 0010 0 0000
			01010100 00000000 00000000 01000000

			; jump forward 7 instructions past ascii bit routine
			; 0 0 0 1 0 1 imm26
			; 0 0 0 1 0 1 00 0000 0000 0000 0000 0000 0111
			00010100 00000000 00000000 00000111

			; # routine for ascii bits

				; compare r3 to r31
				; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
				; Rn ? Rm
				; r3 ? r31
				; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00011 0 0 0 0 0
				11111010 01011111 11110000 01100000

				; if equal, jump forward 5 instructions past end of loop
				; 0 1 0 1 0 1 0 0 imm19 0 cond4
				; imm = 18 ; cond = 0000
				; 0 1 0 1 0 1 0 0 000 0000 0000 0000 0101 0 0000
				01010100 00000000 00000000 10100000

				; subtract 1 from r3
				; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
				; Rd <= Rn - (uimm << (shift ? 12 : 0))
				; r3 <= r3 - (1 << (0 ? 12 : 0))
				; 1 1 0 1 0 0 0 1 0 0 0000 0000 0001 00011 00011
				11010001 00000000 00000100 01100011

				; # copy ascii bit to memOut

					; store r2 into *r13
					; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
					; *(Rn + imm) <= Rt
					; *(r13 + 0) <= r2
					; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01101 00010
					10111000 00000000 00000001 10100010

					; add 0x1 to r13
					; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
					; Rd <= Rn + (uimm << (shift ? 12 : 0))
					; r13 <= r13 + (0x1 << (0 ? 12 : 0))
					; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01101 01101
					10010001 00000000 00000101 10101101

					; jump back 20 instructions to beginning of loop
					; 0 0 0 1 0 1 imm26
					; 0 0 0 1 0 1 11 1111 1111 1111 1111 1110 1100
					00010111 11111111 11111111 11101100

		; # handle unrecognized characters

			; subtract 1 from r12
			; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
			; Rd <= Rn - (uimm << (shift ? 12 : 0))
			; r12 <= r12 - (1 << (0 ? 12 : 0))
			; 1 1 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01110
			11010001 00000000 00000101 10001100

			; compare r3 to r31
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r3 ? r31
			; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00011 0 0 0 0 0
			11111010 01011111 11110000 01100000

			; if equal, jump forward 11 instructions past end of loop
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = 11 ; cond = 0000
			; 0 1 0 1 0 1 0 0 000 0000 0000 0000 1011 0 0000
			01010100 00000000 00000001 01100000

			; # unexpected non-binary character error

				; copy r2 to r15
				; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Rn5 Rd5
			  ; (Rd or *SP) <= (Rn or *SP)
			  ; r15 <= r2
			  ; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00010 01111
			  10010001 00000000 00000000 01001111

				; set r2 to '!' (0x21)
				; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
				; Rd <= imm << hw*16
				; r2 <= 0x21 << 0*16
				; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0001 00010
				11010010 10000000 00000100 00100010

				; # print r2

					; move 0x20 (1<<5) into r0
					; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
					; Rd <= imm << hw*16
					; r0 <= 0x10 << 0*16
					; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00000
					11010010 10000000 00000100 00000000

					; load *(r9+0x18) into r1
					; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
					; Rt <= *(Rn + imm)
					; r1 <= *(r9 + 0x18)
					; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
					11111000 01000001 10000001 00100001

					; check flag at bit index five
					; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
					; Rd <= Rn # Rm
					; r1 <= r1 & r0
					; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
					; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
					10001010 00000000 00000000 00100001

					; compare r1 to r0
					; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
					; Rn ? Rm
					; r1 ? r31
					; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
					11111010 01011111 11110000 00100000

					; if greater than, jump back three instructions
					; 0 1 0 1 0 1 0 0 imm19 0 cond4
					; imm = -2 ; cond = 1100
					; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
					01010100 11111111 11111111 10100001

					; store r2 into *r9
					; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
					; *(Rn + imm) <= Rt
					; *(r9 + 0) <= r2
					; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01001 00010
					10111000 00000000 00000001 00100010

				; enter sleep state
				; 1101 0101 0000 0011 0010 0000 0101 1111
				11010101 00000011 00100000 01011111

				; jump back one instruction
				; 0 0 0 1 0 1 imm26
				; 0 0 0 1 0 1 11 1111 1111 1111 1111 1111 1111
				00010111 11111111 11111111 11111111

	; load *r12 into r2
	; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
	; Rt <= *(Rn + imm)
	; r2 <= *(r12 + 0)
	; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
	00111001 01000000 00000001 10000010

	; add 0x1 to r12
	; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn + (uimm << (shift ? 12 : 0))
	; r12 <= r12 + (0x1 << (0 ? 12 : 0))
	; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01100
	10010001 00000000 00000101 10001100

	; set r1 to '\n' (10)
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r2 <= 0x21 << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 1010 00001
	11010010 10000000 00000001 01000001

	; compare r1 to r2
	; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
	; Rn ? Rm
	; r1 ? r2
	; 1 1 1 1 1 0 1 0 0 1 0 00010 1 1 1 1 0 0 00001 0 0 0 0 0
	11111010 01000010 11110000 00100000

	; if not equal, jump forward 3 instructions to code checking for null byte
	; 0 1 0 1 0 1 0 0 imm19 0 cond4
	; imm = 3 ; cond = 0001
	; 0 1 0 1 0 1 0 0 000 0000 0000 0000 0011 0 0001
	01010100 00000000 00000000 01100001

	; load *r12 into r2
	; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
	; Rt <= *(Rn + imm)
	; r2 <= *(r12 + 0)
	; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
	00111001 01000000 00000001 10000010

	; add 0x1 to r12
	; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn + (uimm << (shift ? 12 : 0))
	; r12 <= r12 + (0x1 << (0 ? 12 : 0))
	; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01100
	10010001 00000000 00000101 10001100

	; compare r2 to r31
	; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
	; Rn ? Rm
	; r2 ? r31
	; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00010 0 0 0 0 0
	11111010 01011111 11110000 01000000

	; if equal, jump 3 instructions past the end of this compiler phase
	; 0 1 0 1 0 1 0 0 imm19 0 cond4
	; imm = -43 ; cond = 0001
	; 0 1 0 1 0 1 0 0 000 0000 0000 0000 0011 0 0000
	01010100 00000000 00000000 01100000

	; subtract 1 from r12
	; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	; Rd <= Rn - (uimm << (shift ? 12 : 0))
	; r12 <= r12 - (1 << (0 ? 12 : 0))
	; 1 1 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01100
	11010001 00000000 00000101 10001100

	; if not equal, jump back 45 intructions to beginning of compiler loop
	; 0 0 0 1 0 1 imm26
	; 0 0 0 1 0 1 11 1111 1111 1111 1111 1101 0011
	00010111 11111111 11111111 11010011

; # compute length of output

	; subtract r12 from r13, store into r14
	; 1 1 0 0 1 0 1 1 00 0 Rm5 000000 Rn5 Rd5
	; Rd <= Rn - Rm
	; r14 <= r13 - r12
	; 1 1 0 0 1 0 1 1 00 0 01100 000000 01101 01110
	11001011 00001100 00000001 10101110

	; divide by 8 (because we convert ascii bits to bytes)
	; r14 <= r31 | (r2 << 3)
	; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
	; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
	; opc = 01 ; shift = 1 ; uimm = 8
	; r14 <= r32 | (r2 << 3)
	; 1 01 0 1 0 1 0 0 1 0 01110 000011 11111 01110
	10101010 01001110 00001111 11101110

; # print length in four bytes

	; move 0xff into r3
	; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
	; Rd <= imm << hw*16
	; r3 <= 0xff << 0*16
	; 1 1 0 1 0 0 1 0 1 00 0000 0000 1111 1111 00011
	11010010 10000000 00011111 11100011
	
	; r2 <= r14 & (r3 << 24)
	; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
	; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
	; opc = 00 ; shift = 0 ; uimm = 24
	; r2 <= r14 & (r3 << 24)
	; 1 00 0 1 0 1 0 0 0 0 00011 011000 01110 00010
	10001010 00000011 01100001 11000010

	; r2 <= r31 | (r2 >> 24)
	; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
	; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
	; opc = 01 ; shift = 1 ; uimm = 24
	; r2 <= r32 | (r2 >> 24)
	; 1 01 0 1 0 1 0 0 1 0 00010 011000 11111 00010
	10101010 01000010 01100011 11100010

	; # print r2

		; move 0x20 (1<<5) into r0
		; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
		; Rd <= imm << hw*16
		; r0 <= 0x10 << 0*16
		; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00000
		11010010 10000000 00000100 00000000

		; load *(r9+0x18) into r1
		; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r1 <= *(r9 + 0x18)
		; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
		11111000 01000001 10000001 00100001

		; check flag at bit index five
		; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
		; Rd <= Rn # Rm
		; r1 <= r1 & r0
		; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
		; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
		10001010 00000000 00000000 00100001

		; compare r1 to r0
		; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
		; Rn ? Rm
		; r1 ? r31
		; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
		11111010 01011111 11110000 00100000

		; if greater than, jump back three instructions
		; 0 1 0 1 0 1 0 0 imm19 0 cond4
		; imm = -2 ; cond = 1100
		; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
		01010100 11111111 11111111 10100001

		; store r2 into *r9
		; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
		; *(Rn + imm) <= Rt
		; *(r9 + 0) <= r2
		; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01001 00010
		10111000 00000000 00000001 00100010
	
	; r2 <= r14 & (r3 << 16)
	; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
	; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
	; opc = 00 ; shift = 0 ; uimm = 16
	; r2 <= r14 & (r3 << 16)
	; 1 00 0 1 0 1 0 0 0 0 00011 010000 01110 00010
	10001010 00000011 01000001 11000010

	; r2 <= r31 | (r2 >> 16)
	; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
	; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
	; opc = 01 ; shift = 1 ; uimm = 16
	; r2 <= r32 | (r2 >> 16)
	; 1 01 0 1 0 1 0 0 1 0 00010 010000 11111 00010
	10101010 01000010 01000011 11100010

	; # print r2

		; move 0x20 (1<<5) into r0
		; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
		; Rd <= imm << hw*16
		; r0 <= 0x10 << 0*16
		; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00000
		11010010 10000000 00000100 00000000

		; load *(r9+0x18) into r1
		; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r1 <= *(r9 + 0x18)
		; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
		11111000 01000001 10000001 00100001

		; check flag at bit index five
		; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
		; Rd <= Rn # Rm
		; r1 <= r1 & r0
		; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
		; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
		10001010 00000000 00000000 00100001

		; compare r1 to r0
		; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
		; Rn ? Rm
		; r1 ? r31
		; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
		11111010 01011111 11110000 00100000

		; if greater than, jump back three instructions
		; 0 1 0 1 0 1 0 0 imm19 0 cond4
		; imm = -2 ; cond = 1100
		; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
		01010100 11111111 11111111 10100001

		; store r2 into *r9
		; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
		; *(Rn + imm) <= Rt
		; *(r9 + 0) <= r2
		; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01001 00010
		10111000 00000000 00000001 00100010
	
	; r2 <= r14 & (r3 << 8)
	; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
	; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
	; opc = 00 ; shift = 0 ; uimm = 8
	; r2 <= r14 & (r3 << 16)
	; 1 00 0 1 0 1 0 0 0 0 00011 001000 01110 00010
	10001010 00000011 00100001 11000010

	; r2 <= r31 | (r2 >> 8)
	; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
	; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
	; opc = 01 ; shift = 1 ; uimm = 8
	; r2 <= r32 | (r2 >> 8)
	; 1 01 0 1 0 1 0 0 1 0 00010 001000 11111 00010
	10101010 01000010 00100011 11100010

	; # print r2

		; move 0x20 (1<<5) into r0
		; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
		; Rd <= imm << hw*16
		; r0 <= 0x10 << 0*16
		; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00000
		11010010 10000000 00000100 00000000

		; load *(r9+0x18) into r1
		; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r1 <= *(r9 + 0x18)
		; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
		11111000 01000001 10000001 00100001

		; check flag at bit index five
		; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
		; Rd <= Rn # Rm
		; r1 <= r1 & r0
		; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
		; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
		10001010 00000000 00000000 00100001

		; compare r1 to r0
		; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
		; Rn ? Rm
		; r1 ? r31
		; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
		11111010 01011111 11110000 00100000

		; if greater than, jump back three instructions
		; 0 1 0 1 0 1 0 0 imm19 0 cond4
		; imm = -2 ; cond = 1100
		; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
		01010100 11111111 11111111 10100001

		; store r2 into *r9
		; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
		; *(Rn + imm) <= Rt
		; *(r9 + 0) <= r2
		; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01001 00010
		10111000 00000000 00000001 00100010
	
	; r2 <= r14 & r3
	; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
	; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
	; opc = 00 ; shift = 0 ; uimm = 0
	; r2 <= r14 & (r3 << 0)
	; 1 00 0 1 0 1 0 0 0 0 00011 000000 01110 00010
	10001010 00000011 00000001 11000010

	; # print r2

		; move 0x20 (1<<5) into r0
		; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
		; Rd <= imm << hw*16
		; r0 <= 0x10 << 0*16
		; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00000
		11010010 10000000 00000100 00000000

		; load *(r9+0x18) into r1
		; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r1 <= *(r9 + 0x18)
		; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
		11111000 01000001 10000001 00100001

		; check flag at bit index five
		; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
		; Rd <= Rn # Rm
		; r1 <= r1 & r0
		; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
		; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
		10001010 00000000 00000000 00100001

		; compare r1 to r0
		; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
		; Rn ? Rm
		; r1 ? r31
		; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
		11111010 01011111 11110000 00100000

		; if greater than, jump back three instructions
		; 0 1 0 1 0 1 0 0 imm19 0 cond4
		; imm = -2 ; cond = 1100
		; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
		01010100 11111111 11111111 10100001

		; store r2 into *r9
		; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
		; *(Rn + imm) <= Rt
		; *(r9 + 0) <= r2
		; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01001 00010
		10111000 00000000 00000001 00100010

; # print memOut to uartOut

	; copy r12 into r14
	; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Rn5 Rd5
  ; (Rd or *SP) <= (Rn or *SP)
  ; r14 <= r12
  ; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 01100 01110
  10010001 00000000 00000001 10001110

	; # byte #1

		; r12 = r14 + 24
		; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	  ; Rd <= Rn + (uimm << (shift ? 12 : 0))
	  ; r12 <= r14 + (24 << (0 ? 12 : 0))
	  ; 1 0 0 1 0 0 0 1 0 0 0000 0001 1000 01110 01100
	  10010001 00000000 01100001 11001100

		; # convert eight ascii bits to a byte

			; set r1 to 8
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r2 <= 32 << 8*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 1000 00001
			11010010 10000000 00000001 00000001

			; set r3 to 0
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r2 <= 32 << 8*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 0000 00011
			11010010 10000000 00000000 00000011

			; load *r12 into r2
			; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
			; Rt <= *(Rn + imm)
			; r2 <= *(r12 + 0)
			; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
			00111001 01000000 00000001 10000010

			; add 0x1 to r12
			; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
			; Rd <= Rn + (uimm << (shift ? 12 : 0))
			; r12 <= r12 + (0x1 << (0 ? 12 : 0))
			; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01100
			10010001 00000000 00000101 10001100

			; subtract 0x30 from r2
			; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
			; Rd <= Rn - (uimm << (shift ? 12 : 0))
			; r2 <= r2 - (1 << (0 ? 12 : 0))
			; 1 1 0 1 0 0 0 1 0 0 0000 0011 0000 00010 00010
			11010001 00000000 11000000 01000010

			; r3 <= r2 | (r3 << 1)
			; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
			; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
			; opc = 01 ; shift = 0 ; uimm = 1
			; r3 <= r2 | (r3 << 1)
			; 1 01 0 1 0 1 0 0 0 0 00011 000001 00010 00011
			10101010 00000011 00000100 01000011

			; subtract 1 from r1
			; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
			; Rd <= Rn - (uimm << (shift ? 12 : 0))
			; r1 <= r1 - (1 << (0 ? 12 : 0))
			; 1 1 0 1 0 0 0 1 0 0 0000 0000 0001 00001 00001
			11010001 00000000 00000100 00100001

			; compare r1 to r31
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r1 ? r31
			; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
			11111010 01011111 11110000 00100000

			; if not equal, jump back 6 instructions
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = -6 ; cond = 0001
			; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1010 0 0001
			01010100 11111111 11111111 01000001

		; move r3 into r2
		; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Rn5 Rd5
		; (Rd or *SP) <= (Rn or *SP)
		; r2 <= r3
		; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00011 00010
		10010001 00000000 00000000 01100010

		; # wait for UART flags register *(r9+0x18) to say we're ready to write

			; move 0x20 (1<<5) into r0
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r0 <= 0x10 << 0*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00000
			11010010 10000000 00000100 00000000

			; load *(r9+0x18) into r1
			; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
			; Rt <= *(Rn + imm)
			; r1 <= *(r9 + 0x18)
			; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
			11111000 01000001 10000001 00100001

			; check flag at bit index five
			; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
			; Rd <= Rn # Rm
			; r1 <= r1 & r0
			; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
			; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
			10001010 00000000 00000000 00100001

			; compare r1 to r0
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r1 ? r31
			; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
			11111010 01011111 11110000 00100000

			; if greater than, jump back three instructions
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = -2 ; cond = 1100
			; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
			01010100 11111111 11111111 10100001

			; store r2 into *r9
			; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
			; *(Rn + imm) <= Rt
			; *(r9 + 0) <= r2
			; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01001 00010
			10111000 00000000 00000001 00100010

		; load *r12 into r2
		; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r2 <= *(r12 + 0)
		; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
		00111001 01000000 00000001 10000010

	; # byte #2

		; r12 = r14 + 16
		; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	  ; Rd <= Rn + (uimm << (shift ? 12 : 0))
	  ; r12 <= r14 + (16 << (0 ? 12 : 0))
	  ; 1 0 0 1 0 0 0 1 0 0 0000 0001 0000 01110 01100
	  10010001 00000000 01000001 11001100

		; # convert eight ascii bits to a byte

			; set r1 to 8
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r2 <= 32 << 8*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 1000 00001
			11010010 10000000 00000001 00000001

			; set r3 to 0
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r2 <= 32 << 8*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 0000 00011
			11010010 10000000 00000000 00000011

			; load *r12 into r2
			; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
			; Rt <= *(Rn + imm)
			; r2 <= *(r12 + 0)
			; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
			00111001 01000000 00000001 10000010

			; add 0x1 to r12
			; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
			; Rd <= Rn + (uimm << (shift ? 12 : 0))
			; r12 <= r12 + (0x1 << (0 ? 12 : 0))
			; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01100
			10010001 00000000 00000101 10001100

			; subtract 0x30 from r2
			; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
			; Rd <= Rn - (uimm << (shift ? 12 : 0))
			; r2 <= r2 - (1 << (0 ? 12 : 0))
			; 1 1 0 1 0 0 0 1 0 0 0000 0011 0000 00010 00010
			11010001 00000000 11000000 01000010

			; r3 <= r2 | (r3 << 1)
			; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
			; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
			; opc = 01 ; shift = 0 ; uimm = 1
			; r3 <= r2 | (r3 << 1)
			; 1 01 0 1 0 1 0 0 0 0 00011 000001 00010 00011
			10101010 00000011 00000100 01000011

			; subtract 1 from r1
			; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
			; Rd <= Rn - (uimm << (shift ? 12 : 0))
			; r1 <= r1 - (1 << (0 ? 12 : 0))
			; 1 1 0 1 0 0 0 1 0 0 0000 0000 0001 00001 00001
			11010001 00000000 00000100 00100001

			; compare r1 to r31
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r1 ? r31
			; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
			11111010 01011111 11110000 00100000

			; if not equal, jump back 6 instructions
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = -6 ; cond = 0001
			; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1010 0 0001
			01010100 11111111 11111111 01000001

		; move r3 into r2
		; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Rn5 Rd5
		; (Rd or *SP) <= (Rn or *SP)
		; r2 <= r3
		; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00011 00010
		10010001 00000000 00000000 01100010

		; # wait for UART flags register *(r9+0x18) to say we're ready to write

			; move 0x20 (1<<5) into r0
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r0 <= 0x10 << 0*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00000
			11010010 10000000 00000100 00000000

			; load *(r9+0x18) into r1
			; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
			; Rt <= *(Rn + imm)
			; r1 <= *(r9 + 0x18)
			; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
			11111000 01000001 10000001 00100001

			; check flag at bit index five
			; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
			; Rd <= Rn # Rm
			; r1 <= r1 & r0
			; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
			; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
			10001010 00000000 00000000 00100001

			; compare r1 to r0
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r1 ? r31
			; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
			11111010 01011111 11110000 00100000

			; if greater than, jump back three instructions
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = -2 ; cond = 1100
			; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
			01010100 11111111 11111111 10100001

			; store r2 into *r9
			; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
			; *(Rn + imm) <= Rt
			; *(r9 + 0) <= r2
			; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01001 00010
			10111000 00000000 00000001 00100010

		; load *r12 into r2
		; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r2 <= *(r12 + 0)
		; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
		00111001 01000000 00000001 10000010

	; # byte #3

		; r12 = r14 + 8
		; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
	  ; Rd <= Rn + (uimm << (shift ? 12 : 0))
	  ; r12 <= r14 + (8 << (0 ? 12 : 0))
	  ; 1 0 0 1 0 0 0 1 0 0 0000 0000 1000 01110 01100
	  10010001 00000000 00100001 11001100

		; # convert eight ascii bits to a byte

			; set r1 to 8
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r2 <= 32 << 8*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 1000 00001
			11010010 10000000 00000001 00000001

			; set r3 to 0
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r2 <= 32 << 8*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 0000 00011
			11010010 10000000 00000000 00000011

			; load *r12 into r2
			; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
			; Rt <= *(Rn + imm)
			; r2 <= *(r12 + 0)
			; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
			00111001 01000000 00000001 10000010

			; add 0x1 to r12
			; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
			; Rd <= Rn + (uimm << (shift ? 12 : 0))
			; r12 <= r12 + (0x1 << (0 ? 12 : 0))
			; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01100
			10010001 00000000 00000101 10001100

			; subtract 0x30 from r2
			; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
			; Rd <= Rn - (uimm << (shift ? 12 : 0))
			; r2 <= r2 - (1 << (0 ? 12 : 0))
			; 1 1 0 1 0 0 0 1 0 0 0000 0011 0000 00010 00010
			11010001 00000000 11000000 01000010

			; r3 <= r2 | (r3 << 1)
			; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
			; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
			; opc = 01 ; shift = 0 ; uimm = 1
			; r3 <= r2 | (r3 << 1)
			; 1 01 0 1 0 1 0 0 0 0 00011 000001 00010 00011
			10101010 00000011 00000100 01000011

			; subtract 1 from r1
			; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
			; Rd <= Rn - (uimm << (shift ? 12 : 0))
			; r1 <= r1 - (1 << (0 ? 12 : 0))
			; 1 1 0 1 0 0 0 1 0 0 0000 0000 0001 00001 00001
			11010001 00000000 00000100 00100001

			; compare r1 to r31
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r1 ? r31
			; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
			11111010 01011111 11110000 00100000

			; if not equal, jump back 6 instructions
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = -6 ; cond = 0001
			; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1010 0 0001
			01010100 11111111 11111111 01000001

		; move r3 into r2
		; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Rn5 Rd5
		; (Rd or *SP) <= (Rn or *SP)
		; r2 <= r3
		; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00011 00010
		10010001 00000000 00000000 01100010

		; # wait for UART flags register *(r9+0x18) to say we're ready to write

			; move 0x20 (1<<5) into r0
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r0 <= 0x10 << 0*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00000
			11010010 10000000 00000100 00000000

			; load *(r9+0x18) into r1
			; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
			; Rt <= *(Rn + imm)
			; r1 <= *(r9 + 0x18)
			; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
			11111000 01000001 10000001 00100001

			; check flag at bit index five
			; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
			; Rd <= Rn # Rm
			; r1 <= r1 & r0
			; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
			; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
			10001010 00000000 00000000 00100001

			; compare r1 to r0
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r1 ? r31
			; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
			11111010 01011111 11110000 00100000

			; if greater than, jump back three instructions
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = -2 ; cond = 1100
			; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
			01010100 11111111 11111111 10100001

			; store r2 into *r9
			; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
			; *(Rn + imm) <= Rt
			; *(r9 + 0) <= r2
			; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01001 00010
			10111000 00000000 00000001 00100010

		; load *r12 into r2
		; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r2 <= *(r12 + 0)
		; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
		00111001 01000000 00000001 10000010

	; # byte #4

		; r12 = r14 + 0
		; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Rn5 Rd5
	  ; (Rd or *SP) <= (Rn or *SP)
	  ; r12 <= r14
	  ; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 01110 01100
	  10010001 00000000 00000001 11001100

		; # convert eight ascii bits to a byte

			; set r1 to 8
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r2 <= 32 << 8*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 1000 00001
			11010010 10000000 00000001 00000001

			; set r3 to 0
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r2 <= 32 << 8*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0000 0000 00011
			11010010 10000000 00000000 00000011

			; load *r12 into r2
			; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
			; Rt <= *(Rn + imm)
			; r2 <= *(r12 + 0)
			; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
			00111001 01000000 00000001 10000010

			; add 0x1 to r12
			; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
			; Rd <= Rn + (uimm << (shift ? 12 : 0))
			; r12 <= r12 + (0x1 << (0 ? 12 : 0))
			; 1 0 0 1 0 0 0 1 0 0 0000 0000 0001 01100 01100
			10010001 00000000 00000101 10001100

			; subtract 0x30 from r2
			; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
			; Rd <= Rn - (uimm << (shift ? 12 : 0))
			; r2 <= r2 - (1 << (0 ? 12 : 0))
			; 1 1 0 1 0 0 0 1 0 0 0000 0011 0000 00010 00010
			11010001 00000000 11000000 01000010

			; r3 <= r2 | (r3 << 1)
			; 1 opc2 0 1 0 1 0 0 shift1 0 Rm5 uimm6 Rn5 Rd5
			; Rd <= Rn # (shift ? Rm >> uimm : out << uimm)
			; opc = 01 ; shift = 0 ; uimm = 1
			; r3 <= r2 | (r3 << 1)
			; 1 01 0 1 0 1 0 0 0 0 00011 000001 00010 00011
			10101010 00000011 00000100 01000011

			; subtract 1 from r1
			; 1 1 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
			; Rd <= Rn - (uimm << (shift ? 12 : 0))
			; r1 <= r1 - (1 << (0 ? 12 : 0))
			; 1 1 0 1 0 0 0 1 0 0 0000 0000 0001 00001 00001
			11010001 00000000 00000100 00100001

			; compare r1 to r31
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r1 ? r31
			; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
			11111010 01011111 11110000 00100000

			; if not equal, jump back 6 instructions
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = -6 ; cond = 0001
			; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1010 0 0001
			01010100 11111111 11111111 01000001

		; move r3 into r2
		; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Rn5 Rd5
		; (Rd or *SP) <= (Rn or *SP)
		; r2 <= r3
		; 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00011 00010
		10010001 00000000 00000000 01100010

		; # wait for UART flags register *(r9+0x18) to say we're ready to write

			; move 0x20 (1<<5) into r0
			; 1 1 0 1 0 0 1 0 1 hw2 imm16 Rd5
			; Rd <= imm << hw*16
			; r0 <= 0x10 << 0*16
			; 1 1 0 1 0 0 1 0 1 00 0000 0000 0010 0000 00000
			11010010 10000000 00000100 00000000

			; load *(r9+0x18) into r1
			; 1 1 1 1 1 0 0 0 0 1 0 imm9 0 0 Rn5 Rt5
			; Rt <= *(Rn + imm)
			; r1 <= *(r9 + 0x18)
			; 1 1 1 1 1 0 0 0 0 1 0 000011000 0 0 01001 00001
			11111000 01000001 10000001 00100001

			; check flag at bit index five
			; 1 opc2 0 1 0 1 0 shift2 N Rm5 imms6 Rn5 Rd5
			; Rd <= Rn # Rm
			; r1 <= r1 & r0
			; opc = 00 ; shift = 00 ; N = 0 ; imms = 0
			; 1 00 0 1 0 1 0 00 0 00000 000000 00001 00001
			10001010 00000000 00000000 00100001

			; compare r1 to r0
			; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
			; Rn ? Rm
			; r1 ? r31
			; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00001 0 0 0 0 0
			11111010 01011111 11110000 00100000

			; if greater than, jump back three instructions
			; 0 1 0 1 0 1 0 0 imm19 0 cond4
			; imm = -2 ; cond = 1100
			; 0 1 0 1 0 1 0 0 111 1111 1111 1111 1101 0 1100
			01010100 11111111 11111111 10100001

			; store r2 into *r9
			; 1 0 1 1 1 0 0 0 0 0 0 imm9 0 0 Rn5 Rt5
			; *(Rn + imm) <= Rt
			; *(r9 + 0) <= r2
			; 1 0 1 1 1 0 0 0 0 0 0 000000000 0 0 01001 00010
			10111000 00000000 00000001 00100010

		; load *r12 into r2
		; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
		; Rt <= *(Rn + imm)
		; r2 <= *(r12 + 0)
		; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
		00111001 01000000 00000001 10000010

; r12 = r14 + 32
; 1 0 0 1 0 0 0 1 0 shift1 uimm12 Rn5 Rd5
; Rd <= Rn + (uimm << (shift ? 12 : 0))
; r12 <= r14 + (32 << (0 ? 12 : 0))
; 1 0 0 1 0 0 0 1 0 0 0000 0010 0000 01110 01100
10010001 00000000 10000001 11001100

; load *r12 into r2
; 0 0 1 1 1 0 0 1 0 1 imm12 Rn5 Rt5
; Rt <= *(Rn + imm)
; r2 <= *(r12 + 0)
; 0 0 1 1 1 0 0 1 0 1 0000 0000 0000 01100 00010
00111001 01000000 00000001 10000010

; compare r2 to r31
; 1 1 1 1 1 0 1 0 0 1 0 Rm5 1 1 1 1 0 0 Rn5 0 0 0 0 0
; Rn ? Rm
; r2 ? r31
; 1 1 1 1 1 0 1 0 0 1 0 11111 1 1 1 1 0 0 00010 0 0 0 0 0
11111010 01011111 11110000 01000000

; if not equal, jump back 76 instructions
; 0 1 0 1 0 1 0 0 imm19 0 cond4
; imm = -76 ; cond = 0001
; 0 1 0 1 0 1 0 0 111 1111 1111 1011 0100 0 0001
01010100 11111111 11110110 10000001
